/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// PgbenchSpec defines the desired state of Pgbench
// Reference https://www.postgresql.org/docs/current/pgbench.html
type PgbenchSpec struct {
	// The scale factor.
	// Multiply the number of rows generated by the scale factor. For example,
	// scale 100 will create 10,000,000 rows in the pgbench_accounts table.
	// Default is 1. When the scale is 20,000 or larger, the columns used to
	// hold account identifiers (aid columns) will switch to using larger
	// integers (bigint), in order to be big enough to hold the range of account
	// identifiers.
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:default=1
	// +optional
	Scale int `json:"scale,omitempty"`

	// clients provides a list of client counts to run pgbench with multiple times.
	// This allows for multiple runs of pgbench with different client counts.
	// It is different with the clients parameter of pgbench command, which is
	// the number of concurrent clients to run once.
	// +kubebuilder:validation:MinItems=1
	// +kubebuilder:default={1}
	// +optional
	Clients []int `json:"clients,omitempty"`

	// Number of worker threads within pgbench. Using more than one thread can
	// be helpful on multi-CPU machines. Clients are distributed as evenly as
	// possible among available threads. Default is 1.
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:default=1
	// +optional
	Threads int `json:"threads,omitempty"`

	// Establish a connection for each transaction, rather than doing it just
	// once per client session. This is useful to measure the connection overhead.
	// +kubeBuilder:default=false
	// +optional
	Connect bool `json:"connect,omitempty"`

	// Only run the select-only part of the benchmark
	// +optional
	SelectOnly bool `json:"selectOnly,omitempty"`

	// Number of transactions each client runs.
	// Note: the transactions and duration parameters are mutually exclusive.
	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:default=0
	// +optional
	Transactions int `json:"transactions,omitempty"`

	// Run the test for this many seconds, rather than a fixed number of
	// transactions per client.
	// Note: the transactions and duration parameters are mutually exclusive.
	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:default=60
	// +optional
	Duration int `json:"duration,omitempty"`

	// The other pgbench run command options to use for pgbench
	// +optional
	ExtraArgs []string `json:"extraArgs,omitempty"`

	// The target database to run pgbench
	// +required
	Target PgbenchTarget `json:"target"`
}

// PgbenchTarget defines the parameters for the pgbench target database
type PgbenchTarget struct {
	// The database server's host name
	// +kubebuilder:default=localhost
	// +required
	Host string `json:"host"`

	// The database server's port number
	// +kubebuilder:default=5432
	// +required
	Port int `json:"port"`

	// The username to connect as
	// +kubebuilder:default=postgres
	// +required
	User string `json:"user"`

	// The database server's password
	// +optional
	Password string `json:"password,omitempty"`

	// The database name of the target
	// +kubebuilder:default=postgres
	// +required
	Database string `json:"database"`
}

// PgbenchStatus defines the observed state of Pgbench
type PgbenchStatus struct {
	// Phase is the current state of the test. Valid values are Disabled, Enabled, Failed, Enabling, Disabling.
	// +kubebuilder:validation:Enum={Pending,Running,Complete,Failed}
	Phase BenchmarkPhase `json:"phase,omitempty"`

	// completions is the completed/total number of pgbench runs
	Completions string `json:"completions,omitempty"`

	// ready is true when the pgbench benchmark is ready
	Ready bool `json:"ready,omitempty"`

	// succeeded is the number of successful pgbench runs
	Succeeded int `json:"succeeded,omitempty"`

	// total is the number of pgbench runs
	Total int `json:"total,omitempty"`

	// Describes the current state of pgbench benchmark.
	// +optional
	Conditions []metav1.Condition `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="STATUS",type="string",JSONPath=".status.phase",description="status phase"
// +kubebuilder:printcolumn:name="COMPLETIONS",type="string",JSONPath=".status.completions",description="completions"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"

// Pgbench is the Schema for the pgbenches API
type Pgbench struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   PgbenchSpec   `json:"spec,omitempty"`
	Status PgbenchStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// PgbenchList contains a list of Pgbench
type PgbenchList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Pgbench `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Pgbench{}, &PgbenchList{})
}
